<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYUE</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-09T13:26:43.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZYUE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Machine Learning meets iOS Malware -- Identifying Malicious Applications on Apple Environment （译）</title>
    <link href="http://yoursite.com/2017/10/09/Machine-Learning-meets-iOS-Malware/"/>
    <id>http://yoursite.com/2017/10/09/Machine-Learning-meets-iOS-Malware/</id>
    <published>2017-10-09T12:24:01.000Z</published>
    <updated>2017-10-09T13:26:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者：Aniello Cimitile, Fabio Martinelli, Francesco Mercaldo</p>
<p>原文链接：<br><a href="http://www.iit.cnr.it/sites/default/files/machine-learning-meets.pdf" target="_blank" rel="external">http://www.iit.cnr.it/sites/default/files/machine-learning-meets.pdf</a></p>
</blockquote>
<p>摘要：随着智能手机的广泛应用，恶意软件开发团体正在针对移动平台开发越来越具侵略性的软件。虽然科学界已经在Android平台上大量地研究恶意软件，但很少注意到iOS应用程序，可能是因为iOS的闭源性质。在本文中，为弥补这一差距，我们提出了一种在苹果环境下识别恶意应用的方法。我们的方法依赖于一个通过静态分析提取的特征向量。使用20种不同的机器学习算法进行的实验表明，对恶意iOS应用程序和可信应用程序的分类达到了0.971的精确率，1的召回率。<br><a id="more"></a></p>
<p>关键词：恶意软件，iOS，安全，机器学习，测试，静态分析</p>
<h4 id="1-引言和背景"><a href="#1-引言和背景" class="headerlink" title="1. 引言和背景"></a>1. 引言和背景</h4><p>&emsp;&emsp;2007年1月，苹果发布了其智能手机的第一个版本：the iPhone。由于引入了触屏界面和虚拟键盘等创新功能，它标志着全球智能手机市场的革命。当时，苹果的iPhone是智能手机市场的主要增长驱动力，推动着竞争对手开发新产品和操作系统以应对新的市场需求。</p>
<p>&emsp;&emsp;多年来不断增长的现有应用程序数量也证实了iPhone的巨大市场扩张。在2010年3月，App Store中有15万个可供下载的应用程序。 到2015年6月，应用的数量达到150万，是2010年初的10倍。可获取的应用程序数量的增长与新开发应用程序的发布数量直接相关。 2015年5月，提交给App Store申请发布的应用数量首次超过54,000。</p>
<p>&emsp;&emsp;就现有量来说，最受欢迎的Apple App Store类别是游戏，大约23％的现有应用属于此类别。 其他现有数量领先的类别有商业应用、教育应用、生活应用和娱乐应用。游戏在下载量方面也处于领先地位。</p>
<p>&emsp;&emsp;在苹果商店下载的应用程序数量在2015年6月份首次达到了1000亿。与前一年750亿的下载量相比，这是一个显着增长。然而，在应用程序短暂的世界里，下载并不等于保留。据估计，全球用户下载的应用程序中，有25%在头六个月内仅被使用一次。</p>
<p>&emsp;&emsp;由于这些原因，随着越来越多的用户从市场上顺手下载应用程序，移动生态系统对恶意软件开发者来说非常有吸引力。典型攻击者编写的代码越来越具攻击性，能够从受感染的设备收集个人信息并窃取银行帐户。</p>
<p>&emsp;&emsp;出于安全考虑，Google Play和Apple App Store已有数百个应用程序被下架，这也证实了攻击愈演愈烈的趋势。McAfee安全专家称，2016年iOS的最大威胁是过于激进和侵入性的广告应用，而Google Play中有相当数量的被恶意程序感染的应用。Google和Apple都迅速地从相关的应用商店中下架了恶意应用程序，但不可避免的是，一些受感染的应用程序仍然会通过筛选。</p>
<p>&emsp;&emsp;从防御的角度来看，免费和商业移动反恶意软件最常采用的基于签名的恶意软件检测技术作用非常有限。并且，由于获取和分类恶意软件签名的过程既费力又耗时，这一检测方法开销很大。</p>
<p>&emsp;&emsp;虽然科学界已经有了很多方法来检测Android环境中的恶意软件（Battista等，2016; Mercaldo等，2016a; Mercaldo等，2016b），但文献中缺少与iOS环境相关的方法。我们认为，在Android环境中，由于其开源性质，研究人员可以轻松检索样本以进行逆向工程分析，而iOS是封源的，源代码提取更加费力，并且需要取得未加密的二进制代码才能分析应用程序，正如我们将在下一节中所解释的那样。</p>
<p>&emsp;&emsp;为弥补这一差距，我们提出了一种在苹果环境下识别恶意应用的方法。</p>
<p>&emsp;&emsp;我们提出了一种使用特征向量代替代码签名的恶意软件检测技术。这个技术（将通过评估来证明）的前提假设是，恶意应用程序和可信应用程序的特征向量的值不同。</p>
<p>&emsp;&emsp;我们将一些操作码在应用程序反汇编代码中的出现视为特征向量。我们的假设是，为了执行其有害行为，恶意应用程序往往会采用与合法应用程序不同的操作码。</p>
<p>&emsp;&emsp;在现有文献中，提出了几种使用特征提取来解决恶意软件检测问题的方法。</p>
<p>&emsp;&emsp;在以往的病毒检测研究中，使用过计数操作码的技术：它成功识别了W32.Evol变质病毒的几种变种（Choucane，Lakhotia，2006）。</p>
<p>&emsp;&emsp;Bilar（Bilar，2007）提出了一种通过对操作码分布进行统计分析来检测恶意代码的机制。这项工作比较了恶意应用程序和可信样本的统计操作码频率，得出结论：恶意应用程序与可信应用程序的操作码频率分布之间有显着的差别。我们对iOS恶意软件完成了类似分析。在参考文献（Rad ， Masrom，2010; Rad等，2012）中，使用了操作码的直方图作为特征，来分辨一个文件是否是另一个文件的变体版本。在参考文献（Rad，Masrom，2010）中，作者采用0.067的阈值，正确地分类了不同混淆版本的变种病毒; 在参考文献（Rad 等，2012）中，作者使用了一个由40个NGCVK家族恶意软件实例、40个良性文件和20个被作者分类为其它病毒文件的样本组成的数据集，得到了100％的检测率。</p>
<p>&emsp;&emsp;（Mercaldo et al., 2016c; Canfora et al., 2015c; Canfora et al., 2015b; Canfora et al., 2015a）的研究人员证实，Android恶意应用程序与可信应用程序的操作码频率分布不同，精确度从0.94到0.97，另外，（Bernardeschi等，2004）的作者研究了Java字节码中的非法信息流。</p>
<p>&emsp;&emsp;关于苹果环境，iSAM（Damopou等人，2011年）是以研究为目的开发的恶意软件原型，它可以无线感染和自我传播到iPhone设备。 这个恶意软件包含六种恶意软件机制，并能够回连到僵尸主控服务器（？）来更新其编程逻辑。</p>
<p>&emsp;&emsp;Garcıa，Rodrıguez，2016）的研究人员研究了iOS恶意软件的特征，并对2009年至2015年间发现的36个iOS恶意软件家族的样本进行了分类。他们的研究结果表明，这些恶意软件大部分分布在官方市场外，以越狱iOS设备为目标，很少利用任何漏洞。</p>
<p>&emsp;&emsp;在作者的认知范围内，本文所述是第一项旨在探索用机器学习技术解决苹果环境中的移动恶意软件问题的工作。</p>
<p>&emsp;&emsp;本文提出以下研究问题：</p>
<p>&emsp;&emsp;&emsp;&emsp;RQ：通过提取出来的特征，能否区分iOS平台上的恶意应用和可信应用？</p>
<p>&emsp;&emsp;本文的其余部分组织如下：下一节说明了提出的特征和检测技术； 第三节讨论评估；第四节描述我们所提出方法的表现；最后一节给出结论和未来工作。</p>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h4><p>&emsp;&emsp;我们使用一组特征对恶意软件进行分类，这些特征对从被分析的应用程序（下文称AUA）里提取出来的操作码中，特定组的出现次数计数。</p>
<p>&emsp;&emsp;我们对AUA中出现的一组操作码生成直方图：每个直方图维度表示与该维度对应的操作码在代码中出现的次数。</p>
<p>&emsp;&emsp;与Android环境不同的是，从iOS样本中获取源码的主要问题在于iOS样本通常是加密的，因此我们需要对其进行解密以获取反汇编的代码。因此，在我们的方法的第一步（即处理）中，我们需要使用未加密的二进制代码来分析恶意的有效载荷。苹果商店中的iOS应用程序可以以IPA文件格式下载，这个文件由Apple加密，因此我们需要对其进行解密。饭制，当恶意示例是dylib，package.deb格式，或是通过Apple Enterprise Provisioning分发的应用程序时，二进制文件不会被加密，我们可以跳这一步。otool工具（带选项-l）可用于验证样本是否被加密，由LC ENCRYPTION INFO命令的cryptid值指示（0表示未加密）（Garcıa，Rodrıguez，2016）。当样本被加密时，用dumpdecrypted来获取未加密的代码。</p>
<p>&emsp;&emsp;一旦我们获得了反汇编代码，我们就计算每个操作码的出现次数，以便选择出现最多的特征：这就是特征选择步骤。我们使用Lucene库提供的NgramTokenizer类来计算出现次数。 值得注意的是，直方图的差异性已被成功应用于恶意软件检测（Rad，Masrom，2010; Rad等，2012）。</p>
<p>&emsp;&emsp;表1展示了恶意应用程序中最常出现的操作码。<br><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_1.png" alt="恶意应用程序中最常出现的操作码"></p>
<p>&emsp;&emsp;特征选择步骤的输出是一系列的直方图，每个AUA有一个直方图；每个直方图有22个维度，其中每个维度对应于模型中包括的22个操作码的一个，除以应用中的操作码总数得到的值。</p>
<p>&emsp;&emsp;为了清楚起见，我们根据以下公式计算每个直方图：</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_2.png" alt=""></p>
<p>&emsp;&emsp;其中F是提取的22个特征之一，令X为第i个函数中的22个操作码（即O）之一的出现次数，N则是组成AUA的函数总数。</p>
<p>&emsp;&emsp;我们对每个应用计算得到20个直方图，也就是说，每个应用的特征向量由直方图的值构成。</p>
<h4 id="3-评估"><a href="#3-评估" class="headerlink" title="3. 评估"></a>3. 评估</h4><p>&emsp;&emsp;我们设计了一个实验以评估所提出的技术的有效性，通过在引言中提出的研究问题RQ来说明。</p>
<p>&emsp;&emsp;评估数据集包括50个可信iOS应用程序和50个真实的iOS恶意应用程序：可信的样本是从App Store检索得到的，而恶意样本来自Contagio Mobile。数据集包括的恶意软件可按安装方法、激活机制和携带恶意有效载荷的性质分成不同类别，数据集中的恶意应用程序都出现在2013年7月至2016年2月间，而可信应用程序是2016年9月下载最多的免费应用。</p>
<p>&emsp;&emsp;表格2显示了我们在这个研究里涉及的恶意软件家族，并附它们在Contagio Mobile网站的上传日期。</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_3.png" alt="table2"></p>
<p>&emsp;&emsp;我们将恶意和可信的应用提交到由VirusTotal提供的57个反恶意应用软件，以分别测试数据集的恶意性和可信性。</p>
<p>&emsp;&emsp;分类分析旨在评估特征能否正确分类恶意程序和可信程序：我们将表3所示的分类算法应用于特征向量。</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_4.png" alt="table3">    </p>
<p>&emsp;&emsp;我们按照以下步骤评估分类方法的有效性：</p>
<p>&emsp;&emsp;1.建立训练集T⊂D;</p>
<p>&emsp;&emsp;2.建立测试集T’= D÷T;</p>
<p>&emsp;&emsp;3.在T上进行训练;</p>
<p>&emsp;&emsp;4.将学习后的分类器应用于T’的每个元素。</p>
<p>&emsp;&emsp;我们进行了十折交叉验证（注：就是将数据集分成10份，轮流将其中9份做训练1份做验证）：我们将这四个步骤重复了10次，每次改变T的组成（因此T’也不同）。 该分析采用了Weka tool，这是一个知名的用于数据挖掘任务的机器学习算法集合。</p>
<p>&emsp;&emsp;我们通过该步骤获得的结果如表4。我们用五个度量来评估分类结果：召回率，精确率，F值，RocArea和MCC（即Matthews相关系数）。</p>
<p>&emsp;&emsp;精确率表示分成该类的所有样本中，真正属于该X类的样本所占比例。即，检索出的相关记录数与检索到的相关不相关记录总数之比：</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_5.png" alt="">    </p>
<p>&emsp;&emsp;其中tp表示真阳性的数量，fp表示假阳性的数量。</p>
<p>&emsp;&emsp;召回率表示所有属于X累的样本中，被分类为该类的样本所占的比例。即，检索出的相关记录与所有相关记录之比。</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_6.png" alt="">    </p>
<p>&emsp;&emsp;其中fn是假阴性的数量。 精确度和召回率是负相关的。</p>
<p>&emsp;&emsp;F值是测试精度的度量。 该值可以解释称精确率和召回率的加权平均值：</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_7.png" alt="">    </p>
<p>&emsp;&emsp;RocArea被定义为正确分类一个随机阳性样本高于一个随机阴性样本的概率。（注：这个RocArea其实就是AUC，即随机选择一个阳性样本po和一个阴性样本ne，设将po分类成阳性的概率为p1，将ne分类成阳性的概率为p2，p1&gt;p2的概率就是AUC）。</p>
<p>&emsp;&emsp;MCC考虑真假阴阳性，通常被认为是一个即使在类别容量相差较大时，也可以使用的平衡值。</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_8.png" alt="">    </p>
<p>&emsp;&emsp;其中tn是真阴性的数量。</p>
<p>&emsp;&emsp;分类结果如表4所示。</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_10.png" alt="table4">    </p>
<p>&emsp;&emsp;我们对恶意应用和可信应用都计算相关度量的值。就精确率来说，识别iOS恶意软件样本的更准确的算法是OneR算法，其精确率等于0,971，召回率等于1。</p>
<p>&emsp;&emsp;对研究问题RQ的回答：评估表明，特征能有效地检测iOS移动恶意软件，用OneR算法获得最佳的检测性能。</p>
<h4 id="4-性能评估"><a href="#4-性能评估" class="headerlink" title="4. 性能评估"></a>4. 性能评估</h4><p>&emsp;&emsp;在本节中，我们将讨论我们方法的性能。 为了评估性能，我们使用System.currentTimeMillis()这个Java方法返回当前时间（以毫秒为单位）。 用于进行实验和进行测量的机器是搭载Linux Mint 15，4 GB RAM，Intel Core i5的台式机。我们考虑将所有时间分析为两个不同贡献的总和： 从iOS应用程序（tfv）中提取特征向量所需的平均时间以及使用OneR算法（tm）学习的模型来测试提取的特征向量所需的时间。我们将分析一个样本的总时间看作两个部分的总和：从iOS应用程序中提取特征向量所需的平均时间（tfv）以及用OneR算法训练的模型来测试所提取特征向量所需的时间（tm）。</p>
<p>&emsp;&emsp;我们的方法的性能如表5所示。</p>
<p><img src="http://oxk3uz1jl.bkt.clouddn.com/2017/10-09/171009_11.png" alt="table5">    </p>
<p>&emsp;&emsp;从计算的角度来看，最重要的部分是tfv，因为tm只需要0.0289秒来评估特征向量：我们提出的方法需要2,1873秒来测试一个新的样本。</p>
<h4 id="5-结论和展望"><a href="#5-结论和展望" class="headerlink" title="5. 结论和展望"></a>5. 结论和展望</h4><p>&emsp;&emsp;虽然科学界已大量研究Android恶意软件，但文献中缺少与iOS环境相关的方法。因此在本文中我们提出一种通过静态分析和机器学习来检测iOS恶意软件的方法。通过OneR算法我们获得了最好的结果。在未来的工作中，我们计划用提取代码的n元语法（n-gram链接）替代出现次数，以尝试改进方法的检测效果，并探索动态分析的用法，例如例提取系统调用序列以识别iOS恶意软件家族。</p>
<p>####6. 致谢 略</p>
<p>####7. 引用 略</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Aniello Cimitile, Fabio Martinelli, Francesco Mercaldo&lt;/p&gt;
&lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;http://www.iit.cnr.it/sites/default/files/machine-learning-meets.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.iit.cnr.it/sites/default/files/machine-learning-meets.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;摘要：随着智能手机的广泛应用，恶意软件开发团体正在针对移动平台开发越来越具侵略性的软件。虽然科学界已经在Android平台上大量地研究恶意软件，但很少注意到iOS应用程序，可能是因为iOS的闭源性质。在本文中，为弥补这一差距，我们提出了一种在苹果环境下识别恶意应用的方法。我们的方法依赖于一个通过静态分析提取的特征向量。使用20种不同的机器学习算法进行的实验表明，对恶意iOS应用程序和可信应用程序的分类达到了0.971的精确率，1的召回率。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="恶意程序" scheme="http://yoursite.com/tags/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>An analysis on iOS Jailbreak（译）</title>
    <link href="http://yoursite.com/2017/08/02/analysis-on-iOS-Jailbreak/"/>
    <id>http://yoursite.com/2017/08/02/analysis-on-iOS-Jailbreak/</id>
    <published>2017-08-02T03:19:48.000Z</published>
    <updated>2017-08-08T12:53:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作者： Huang Heqing</p>
<p>原文链接：<br><a href="https://papers.put.as/papers/ios/2011/ios_jailbreak_analysis.pdf" target="_blank" rel="external">https://papers.put.as/papers/ios/2011/ios_jailbreak_analysis.pdf</a></p>
<p>写在前面：第一次翻译，错误大概很多_<em>(:</em>」∠)_ 另外，这是一篇2011年的旧文章，文章介绍的重放绕过验证的方法已经失效。我也不懂为什么我翻了一篇6年前的文。。</p>
</blockquote>
<h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><h5 id="•-什么是iOS-越狱"><a href="#•-什么是iOS-越狱" class="headerlink" title="• 什么是iOS 越狱"></a>• 什么是iOS 越狱</h5><p>&emsp;&emsp;iOS是Apple的移动操作系统，它来源于Mac OS X，也以Darwin为基础，是一个类Unix 的操作系统。iOS最初是专为iPhone开发的，之后也被用在iPod Touch，iPad 和Apple TV上。 在本文中，iOS特指在iDevices即iPhone，iPod，iPad和Apple TV上运行的小型操作系统。<a id="more"></a>这个操作系统大约使用500M的设备存储空间，它有四个抽象层：Core OS（核心操作系统）层，Core Service（核心服务）层，媒体层和Cocoa Touch层。</p>
<p>&emsp;&emsp;出于安全和商业的原因，Apple不允许其操作系统在第三方硬件上运行，同时对在iDevices上使用iOS也有限制。因此，iOS受到了各种形式的入侵攻击，这些入侵攻击着重于增加Apple不支持的功能。这种入侵就叫iOS越狱。</p>
<h5 id="•-为什么要越狱"><a href="#•-为什么要越狱" class="headerlink" title="• 为什么要越狱"></a>• 为什么要越狱</h5><p>&emsp;&emsp;越狱是一个让iDevices用户获取对iOS操作系统命令行的root访问权限的过程，目的是去除Apple强加的使用限制和访问限制。一旦越狱，iPhone用户就可以（通过像Cydia 这样的安装器）下载App Store不提供的扩展程序和主题，并执行未越狱设备上不可能执行的任务，包括安装Linux之类的非Apple操作系统，或者在旧版本的iDevices上运行多任务（新一代的非越狱设备已有这个功能）。</p>
<p>&emsp;&emsp;Aurik（UCSB的博士生）开发了一个认证服务器来对iOS的旧固件签名（将在后文中介绍），Cydia创始人Jay Freeman通过这个服务器估计得到，有超过10％的iPhone都是越狱的。</p>
<p>&emsp;&emsp;在美国，越狱一台iPod或iPhone的行为属于合法的“合理使用”。然而，有一些越狱者试图非法分享付费的App Store应用程序，这在越狱社区引起了一些冲突，因为它不是越狱的初心，而且显然是非法的。</p>
<h4 id="2-在越狱后“识别”你自己"><a href="#2-在越狱后“识别”你自己" class="headerlink" title="2. 在越狱后“识别”你自己"></a>2. 在越狱后“识别”你自己</h4><p>&emsp;&emsp;为了阻止在设备上运行任意代码，智能手机都有各自的机制。出于安全和商业原因，操作系统和高级应用程序代码在插入设备之前，都需要得到官方签名。Apple出品的iPhone也有类似的几种机制。 以下详细说明了iPhone如何组织iOS固件认证，以及绕过此远程身份认证机制用到的技巧。</p>
<h5 id="•-iOS固件验证机制"><a href="#•-iOS固件验证机制" class="headerlink" title="• iOS固件验证机制"></a>• iOS固件验证机制</h5><p>&emsp;&emsp;SHSH Blob是Signature HaSH的缩写。 SHSH Blob是一个128字节的RSA签名，用于验证较新的Apple iOS设备上固件的有效性。 SHSH Blob基于Challenge-Response（质询-响应）验证机制，在每当iDevices想要升级或降级其iOS版本时，用于验证旧固件的有效性。</p>
<p>&emsp;&emsp;唯一芯片ID即ECID是用于唯一标识Apple iDevices的16位十六进制数字。 ECID现在被广泛认为是Apple的新安全功能，旨在阻止对未来固件的越狱。</p>
<p>&emsp;&emsp;它如何阻止越狱呢？ Apple认证使用了结合设备固件的签名散列SHSH和ECID，其中ECID作为其质询 - 响应认证协议中的质询密钥。 认证是为了在iOS软件上进行数字签名。 质询密钥是固件散列值和ECID的组合。 Apple的响应就是SHSH自身，也就是验证固件所需的数字签名。</p>
<p>&emsp;&emsp;在实际认证过程中，用户会看到“Apple正在 验证恢复…”的提示，在此期间，iDevice和Apple认证服务器之间启动了一个质询-响应协议：固件文件的“部分摘要” 被发送到服务器，然后服务器决定是否给它签名。</p>
<p>&emsp;&emsp;在iOS 软件升级或恢复过程中，iTunes作为签名软件。 当恢复iDevice时，iTunes会请求Apple服务器根据ECID和SHSH为设备生成签名，iTunes只能通过该签名来恢复SHSH中指定的固件版本。 在最新修复的固件中，用户将暂时找不到漏洞，所以也不能进行越狱，因为越狱只能在已经发现某些类型的漏洞的固件版本上进行。 越狱团队需要时间在最近更新的固件中挖掘新漏洞，所以新版本固件在某个时间段内是安全的（不可越狱的）。 然而，这样的情况显然是越狱用户不愿意看到的。 后文将介绍一些漏洞细节。</p>
<h5 id="•-绕过固件认证并识别自己"><a href="#•-绕过固件认证并识别自己" class="headerlink" title="• 绕过固件认证并识别自己"></a>• 绕过固件认证并识别自己</h5><p>&emsp;&emsp;因为质询密钥（ECID+SHSH）是静态的，所以可以保存这个签名的副本用来进行重放攻击，欺骗签名者——iTunes认为一个旧的固件是合法的。为什么我们要得到旧固件的合法性验证呢？因为Apple只会对最新发布的固件版本签名，并且停止在相应iDevices上签名任何更低版本的iOS。当一台iDevice请求官方的恢复时，它只能恢复到更新的固件版本。然而，如2.1所述，越狱只能在旧的、没有打补丁的固件版本上进行。这种官方固件升级机制最初被认为是越狱iDevice的噩梦。</p>
<p>&emsp;&emsp;然而，Aurik正在一个越狱团队工作，这个团队开发出了可以让用户的iTunes指向的服务器。它不仅可以给Apple不再签名的固件版本签名，还可以在认证过程中保存信息，并允许用户在iTune 意外升级了用户固件的情况下，或用户对越狱一无所知时自然地更新到最新版本的情况下降级固件。</p>
<p>&emsp;&emsp;Aurik已经搭建了一个服务器来模仿Apple签名服务器的功能。 和Apple服务器的主要区别在于这个服务器使用“on file”的结果，而不是Apple的即时质询-响应结果。 这个自建服务器扮演中间人（MiM）的角色。 它重放保存的密钥文件以完成质询-响应，欺骗iTunes相信自己正在和官方的Apple认证服务器通信。<br>&emsp;&emsp;然而，如何让iTunes 相信这个自行搭建的服务器仍然是一个问题。在实际中，几种系统都维护了hosts文件，如文件C：\ Windows \ System32 \ … \ hosts \ etc \ hosts（Windows）或/ etc / hosts（Mac OS X），这就为实现这个欺骗计划提供了一个完美的、通过简单的本地操纵就能实现的解决方案。 只需要把111.222.333.111  gs.apple.com这样的条目附加到hosts文件，就足以让iTunes 将请求重定向到地址为111.222.333.111的自行搭建的服务器。</p>
<p>&emsp;&emsp;hosts文件是帮助寻址计算机网络中的网络节点的系统工具之一。 它是操作系统的互联网协议（IP）实现中的常见部分，具有将主机名转换为数字协议地址（即IP地址）的功能，它标识和定位IP网络中的主机。 它和DNS类似但不同，hosts文件由本地计算机管理员直接管理。 因此，该MiM背后的机制与DNS污染类似，但是这是由用户自己完成的。 自行污染本地的hosts文件是不正常的，但这个攻击是无害的。</p>
<h5 id="•-保存SHSH-用于以后的认证（重放攻击）"><a href="#•-保存SHSH-用于以后的认证（重放攻击）" class="headerlink" title="• 保存SHSH 用于以后的认证（重放攻击）"></a>• 保存SHSH 用于以后的认证（重放攻击）</h5><p>&emsp;&emsp;ECID是Apple保护其iDevices不被操纵的安全措施，几乎每个新的iDevice都受到此安全特性的保护。现在，当拥有这个安全特性的iDevice更新到较新的固件而没有保存ECID SHSH blob时，设备不仅会失去越狱环境，而且不能将iDevice降级到较旧的固件。<br>由于越狱做的是Apple官方没有认定的事情，越狱的整个过程被认为是一种自我解放。 当iTunes认为它正在与Apple的身份验证服务器通信时，实际上它是在与构建的服务器通信。 这将让iTunes访问已经存储在服务器中的“on file”签名结果。 这个服务器还可以作为任何SHSH Blob的缓存，扮演Apple服务器的中介。 它能有效地让用户iDevice用“on file”机制注册，这意味着用户现在可以随时降级固件降级。 只要保存了Apple的签名副本并且在之后返回这个签名，就可以用重放攻击满足用户的降级需求。</p>
<p>&emsp;&emsp;另一个应该强调的有意义的点在于：即使一个用户不越狱，也永远不打算越狱，他也应当考虑使用这项“on file”新服务。因为存在这样一种情况，未来Apple发布了新的操作系统，用户接受了升级，然后意外地破坏了一些重要的东西，比如电子邮件帐户或待办事项列表。 如果没有在其他服务器，比如Cydia上保存旧的签名文件，用户将不能降级和还原前一个系统。</p>
<h4 id="3-为什么越狱降级和为不同的iDevices备份旧版本的固件如此重要？"><a href="#3-为什么越狱降级和为不同的iDevices备份旧版本的固件如此重要？" class="headerlink" title="3. 为什么越狱降级和为不同的iDevices备份旧版本的固件如此重要？"></a>3. 为什么越狱降级和为不同的iDevices备份旧版本的固件如此重要？</h4><p>&emsp;&emsp;这是因为越狱工程基于一些旧固件上的不同漏洞。 当一个漏洞被公开的时候，Apple将采取行动来修补它，并发布相关的新固件版本，并停止给旧的可利用的版本签名。 官方固件更新最初被认为是越狱iDevices 的恶梦。 然而，越狱社区会一直在新发布的固件中挖掘新漏洞，或者持有一些很厉害的，新版本可用的漏洞。在本章里面将根据在Bootchain中出现的级别对漏洞进行分类。 然后说明每种类型的漏洞利用的利弊，并通过比较说明差异。</p>
<h5 id="•-iOS-漏洞利用分类和机制"><a href="#•-iOS-漏洞利用分类和机制" class="headerlink" title="• iOS 漏洞利用分类和机制"></a>• iOS 漏洞利用分类和机制</h5><h6 id="1-Userland-漏洞利用"><a href="#1-Userland-漏洞利用" class="headerlink" title="1) Userland 漏洞利用"></a>1) Userland 漏洞利用</h6><p>&emsp;&emsp;userland漏洞是在系统内部发现的漏洞。它利用系统内置应用程序比如如Safari和邮件接收应用中的漏洞来获取root权限。为了明白这一点，需要了解类UNIX的系统的执行层。在类UNIX环境中通常有两个基本的执行级别，一个是内核模式、内核hooks和内核空间内存访问，另一个是用户模式、用户空间内存访问。术语userland是指所有在用户空间而不是内核空间中运行的代码。</p>
<p>&emsp;&emsp;由于userland越狱利用了运行在用户空间中的一些代码的漏洞，因此是完美越狱，因为没有任何内容可能导致iBoot（与内核模式相关）中的恢复模式循环。但是，这种类型的越狱也有缺点：这种漏洞利用只能拿到文件系统权限，拿不到底层的内核控制权。而且，userland漏洞利用的是应用内置的一些不重要代码的脆弱性，因此很容易被修复。 然而，这种类型的漏洞利用更加用户友好和不依赖平台，因为它与应用层相关，与iBoot层无关。</p>
<h6 id="2-iBoot漏洞利用"><a href="#2-iBoot漏洞利用" class="headerlink" title="2) iBoot漏洞利用"></a>2) iBoot漏洞利用</h6><p>&emsp;&emsp;和userland漏洞不同，iBoot漏洞利用提供对iOS很底层的控制，包括文件系统和iBoot权限。</p>
<p>&emsp;&emsp;iBoot漏洞是在iDevices的第三引导程序iBoot上发现的，第一和第二引导程序分别是SecureROM和Low Level BootLoader（LLB，稍后将提及它们。它利用iBoot中的漏洞以关闭代码签名机制，这样用户就可以安装并运行那些做“坏事”的程序啦。如果设备刷新了bootrom，这种漏洞利用可能会失效，因为bootrom会检查LLB，而LLB会检查（被修改的）iBoot，然后就会进入recovery screen，用户需要再次利用这个漏洞才能退出，因此这是不完美越狱。bootrom是完全只读的。在iPod Touch 2G之前的iDevice中，bootrom的只读属性给越狱组织带来了很大便利。因为这意味着Apple不可能通过刷新这些设备中的bootrom来加上对LLB的签名检查，同时也意味着Apple不可能修复旧iDevice上某些类型的旧漏洞。</p>
<p>&emsp;&emsp;iBoot越狱更有价值，因为它是更深层次的漏洞利用。利用这种漏洞，用户可以让设备接受自定义固件，并有可能实现永久越狱。</p>
<h6 id="3-Bootrom漏洞利用"><a href="#3-Bootrom漏洞利用" class="headerlink" title="3) Bootrom漏洞利用"></a>3) Bootrom漏洞利用</h6><p>&emsp;&emsp;由于Apple的新iDevice中加入了新的可刷新的bootrom，越狱组织正在思考新的漏洞利用方法，实现从最底层完全绕过认证链。那就是Bootrom漏洞利用了。这种漏洞利用提供文件系统、iBoot和NOR的权限（自定义引导logo）。Bootrom漏洞存在于iDevice的第一引导程序SecureROM中。它挖掘漏洞以禁用签名检查，可用于加载打补丁的NOR固件（？）。这种漏洞利用不会受限，因为bootrom位于整个认证的代码签名链的最底层，没有什么会去检查bootrom。对这种漏洞，Apple简单打个补丁是不行的，需要更换新的芯片。</p>
<p>&emsp;&emsp;2008年2月27日，iPhone Dev Team证明，他们有能力绕过签名检查，将自定义恢复logo（NOR）加载到iPhone。他们将这个漏洞命名为“Pwnage”。这就是最早的Bootrom漏洞。这是一个超棒的漏洞，因为它来自最底层（硬件闪存中的代码），所以它不能被修复。这个漏洞的利用机制依赖于这样一个事实：Bootrom不会对LLB进行签名检查，从而打破了认证信任链。也就是说，用户可以绕过Bootrom检查来任意地给LLB签名检查打补丁，所以LLB会接受打了补丁的iBoot，而这个iBoot会接受打了补丁的内核，等等等等。</p>
<h5 id="iPhoneLinux-编程——建立用户自己的空间"><a href="#iPhoneLinux-编程——建立用户自己的空间" class="headerlink" title="iPhoneLinux 编程——建立用户自己的空间"></a>iPhoneLinux 编程——建立用户自己的空间</h5><p>&emsp;&emsp;基于前面介绍的分层的漏洞利用分类和相应的机制及工作环境，可以得出下面的Bootchain（引导链）：</p>
<pre><code>SecurityROM → LowLevelBootLoader（LLB） → iBoot → 内核 → 系统软件

Bootrom漏洞利用 → iBoot漏洞利用 → userland漏洞利用
</code></pre><p>&emsp;&emsp;每个高层在加载下一层之前检查下一层的签名。在搜索越狱组织的时候，我发现了一个有趣的项目正在进行，iPhonelinux旨在在iPhone上移植linux，并制作一个自由（免费软件）操作系统以供选择。此项目的目标之一是替换iBoot之后的部分BootChain：</p>
<pre><code>SecurityROM → OpeniBoot → Linux内核 → X服务器  → 窗口管理器
</code></pre><p>&emsp;&emsp;2010年4月21日，基于iPhoneLinux的Android版本发布了，称为iDroid。 到现在为止，到目前为止，iDroid还没有将Linux内核和Google Android操作系统完全移植到Apple的iDevices上。但是基于“OpeniBoot”引导程序的实现，该团队已经完成了在iDevice上启动Linux内核的工作，使用户可以轻松启动Google Android和任何其他基于Linux的操作系统。用户指导视频和简单教程也已经出现。</p>
<p>&emsp;&emsp;用这种方法，用户可以在iDevices上建立自己的游乐场，而不用受到Apple的限制。</p>
<h4 id="附录——漏洞分类举例"><a href="#附录——漏洞分类举例" class="headerlink" title="附录——漏洞分类举例"></a>附录——漏洞分类举例</h4><pre><code>1) Userland 漏洞
○   Symlinks - 适用到 iOS 1.1.1
○   LibTiff - 适用到 iOS 1.1.1
○   Mknod - 适用到 iOS 1.1.2
○   Dual Boot Exploit - 适用到 iOS 2.0 beta 3
○   MobileBackup Copy Exploit - 适用到 iOS 3.1.3
○   Malformed CFF Vulnerability - 适用到 iOS 4.0, 4.0.1
2)  iBoot 漏洞
○   Restore Mode -适用到 iOS 1.0.2
○   Ramdisk Hack - 适用到 iOS 2.0 beta 3
○   diags - 适用到 iOS 2.0 beta 5
○  iBoot Environment Variable Overflow - 适用到 iOS 3.1 beta 3
○  usb_control_msg(0x21, 2) Exploit - 适用到 iOS 3.1.2
○   ARM7 Go - 适用于 iOS 2.1.1
3)  Bootrom 漏洞
○   Pwnage 1.0 (Ramdisk + AppleImage2NORAccess)
○   Pwnage 2.0 (DFU + Malformed Certificate)
○   0x24000 Segment Overflow - only in iBoot-240.4 (old bootrom)
○   usb_control_msg(0xA1, 1) Exploit - in iBoot-240.4 and iBoot-240.5.1   0x24000 Segment Overflow - only in iBoot-359.3
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者： Huang Heqing&lt;/p&gt;
&lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;https://papers.put.as/papers/ios/2011/ios_jailbreak_analysis.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://papers.put.as/papers/ios/2011/ios_jailbreak_analysis.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写在前面：第一次翻译，错误大概很多_&lt;em&gt;(:&lt;/em&gt;」∠)_ 另外，这是一篇2011年的旧文章，文章介绍的重放绕过验证的方法已经失效。我也不懂为什么我翻了一篇6年前的文。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h4&gt;&lt;h5 id=&quot;•-什么是iOS-越狱&quot;&gt;&lt;a href=&quot;#•-什么是iOS-越狱&quot; class=&quot;headerlink&quot; title=&quot;• 什么是iOS 越狱&quot;&gt;&lt;/a&gt;• 什么是iOS 越狱&lt;/h5&gt;&lt;p&gt;&amp;emsp;&amp;emsp;iOS是Apple的移动操作系统，它来源于Mac OS X，也以Darwin为基础，是一个类Unix 的操作系统。iOS最初是专为iPhone开发的，之后也被用在iPod Touch，iPad 和Apple TV上。 在本文中，iOS特指在iDevices即iPhone，iPod，iPad和Apple TV上运行的小型操作系统。
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hello Gitpage</title>
    <link href="http://yoursite.com/2017/08/01/hello-world/"/>
    <id>http://yoursite.com/2017/08/01/hello-world/</id>
    <published>2017-08-01T10:54:48.000Z</published>
    <updated>2017-05-11T02:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<p> (●’◡’●) </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; (●’◡’●) &lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
